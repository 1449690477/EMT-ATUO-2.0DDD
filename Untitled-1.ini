# -*- coding: utf-8 -*-
"""
苏苏多功能自动化工具
- Tab1：赛琪大烟花（武器突破材料本 60 级）
- Tab2：扼守无尽血清 - 人物碎片自动刷取
"""

import os
import sys
import json
import time
import threading
import traceback
import tkinter as tk
from tkinter import ttk, messagebox, filedialog

# ---------- 路径 ----------
if getattr(sys, "frozen", False):
    APP_DIR = os.path.dirname(sys.executable)
    DATA_DIR = getattr(sys, "_MEIPASS", APP_DIR)
else:
    APP_DIR = os.path.dirname(os.path.abspath(__file__))
    DATA_DIR = APP_DIR

BASE_DIR = DATA_DIR
TEMPLATE_DIR = os.path.join(DATA_DIR, "templates")
SCRIPTS_DIR = os.path.join(DATA_DIR, "scripts")
CONFIG_PATH = os.path.join(APP_DIR, "config.json")

# 新项目：人物密函图片 / 掉落物图片
TEMPLATE_LETTERS_DIR = os.path.join(DATA_DIR, "templates_letters")
TEMPLATE_DROPS_DIR = os.path.join(DATA_DIR, "templates_drops")

for d in (TEMPLATE_DIR, SCRIPTS_DIR, TEMPLATE_LETTERS_DIR, TEMPLATE_DROPS_DIR):
    os.makedirs(d, exist_ok=True)

# ---------- 第三方库 ----------
try:
    import pyautogui
    pyautogui.FAILSAFE = False
except Exception:
    pyautogui = None

try:
    import cv2
    import numpy as np
except Exception:
    cv2 = None
    np = None

try:
    import keyboard
except Exception:
    keyboard = None

try:
    import pygetwindow as gw
except Exception:
    gw = None

# ---------- 全局 ----------
DEFAULT_CONFIG = {
    "hotkey": "1",
    "wait_seconds": 8.0,
    "macro_a_path": "",
    "macro_b_path": "",
    "auto_loop": False,
}

GAME_REGION = None
worker_stop = threading.Event()
round_running_lock = threading.Lock()
hotkey_handle = None

app = None           # 赛琪大烟花 GUI 实例
fragment_app = None  # 人物碎片 GUI 实例

# 人物碎片：通用按钮名（放在 templates/）
BTN_OPEN_LETTER = "选择密函.png"
BTN_NEXT_WAVE = "再次挑战.png"
BTN_CONFIRM_LETTER = "确认选择.png"
BTN_RETREAT_START = "撤退.png"


# ---------- 小工具 ----------
def format_hms(sec: float) -> str:
    sec = int(max(0, sec))
    h = sec // 3600
    m = (sec % 3600) // 60
    s = sec % 60
    return f"{h:02d}:{m:02d}:{s:02d}"


# ---------- 日志 / 进度 ----------
def log(msg: str):
    ts = time.strftime("[%H:%M:%S] ")
    print(ts + msg)
    if app is not None:
        app.log(msg)
    if fragment_app is not None:
        fragment_app.log(msg)


def report_progress(p: float):
    if app is not None:
        app.set_progress(p)


# ---------- 配置 ----------
def load_config():
    cfg = DEFAULT_CONFIG.copy()
    if os.path.exists(CONFIG_PATH):
        try:
            with open(CONFIG_PATH, "r", encoding="utf-8") as f:
                cfg.update(json.load(f))
        except Exception as e:
            log(f"读取配置失败：{e}")
    return cfg


def save_config(cfg: dict):
    try:
        with open(CONFIG_PATH, "w", encoding="utf-8") as f:
            json.dump(cfg, f, ensure_ascii=False, indent=2)
        log("配置已保存。")
    except Exception as e:
        log(f"保存配置失败：{e}")


# ---------- 游戏窗口 / 截图 ----------
def find_game_window():
    if gw is None:
        log("未安装 pygetwindow，无法定位游戏窗口。")
        return None
    try:
        wins = gw.getAllWindows()
    except Exception as e:
        log(f"获取窗口列表失败：{e}")
        return None
    for w in wins:
        title = (w.title or "")
        if "二重螺旋" in title and w.width > 400 and w.height > 300:
            return w
    log("未找到标题包含『二重螺旋』的窗口。")
    return None


def init_game_region():
    """以窗口中心 1920x1080 作为识别区域"""
    global GAME_REGION
    if pyautogui is None:
        log("未安装 pyautogui，无法截图。")
        return False
    win = find_game_window()
    if not win:
        return False
    cx = win.left + win.width // 2
    cy = win.top + win.height // 2
    GAME_REGION = (cx - 960, cy - 540, 1920, 1080)
    log(
        f"使用窗口中心区域：left={GAME_REGION[0]}, "
        f"top={GAME_REGION[1]}, w={GAME_REGION[2]}, h={GAME_REGION[3]}"
    )
    return True


def screenshot_game():
    if GAME_REGION is None:
        raise RuntimeError("GAME_REGION 未初始化")
    if pyautogui is None:
        raise RuntimeError("未安装 pyautogui")
    img = pyautogui.screenshot(region=GAME_REGION)
    return cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)


# ---------- 模板匹配（templates/） ----------
def load_template(name: str):
    if cv2 is None or np is None:
        log("缺少 opencv/numpy，无法图像识别。")
        return None
    path = os.path.join(TEMPLATE_DIR, name)
    if not os.path.exists(path):
        log(f"模板不存在：{path}")
        return None
    data = np.fromfile(path, dtype=np.uint8)
    img = cv2.imdecode(data, cv2.IMREAD_GRAYSCALE)
    if img is None:
        log(f"无法读取模板：{path}")
    return img


def match_template(name: str):
    tpl = load_template(name)
    if tpl is None:
        return 0.0, None, None
    img = screenshot_game()
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    res = cv2.matchTemplate(gray, tpl, cv2.TM_CCOEFF_NORMED)
    _, max_val, _, max_loc = cv2.minMaxLoc(res)
    th, tw = tpl.shape[:2]
    x = GAME_REGION[0] + max_loc[0] + tw // 2
    y = GAME_REGION[1] + max_loc[1] + th // 2
    return max_val, x, y


def wait_for_template(name, step_name, timeout=20.0, threshold=0.5):
    start = time.time()
    while time.time() - start < timeout and not worker_stop.is_set():
        score, _, _ = match_template(name)
        log(f"{step_name} 匹配度 {score:.3f}")
        if score >= threshold:
            log(f"{step_name} 匹配成功。")
            return True
        time.sleep(0.5)
    return False


def wait_and_click_template(name, step_name, timeout=15.0, threshold=0.8):
    start = time.time()
    while time.time() - start < timeout and not worker_stop.is_set():
        score, x, y = match_template(name)
        log(f"{step_name} 匹配度 {score:.3f}")
        if score >= threshold and x is not None:
            pyautogui.click(x, y)
            log(f"{step_name} 点击 ({x},{y})")
            return True
        time.sleep(0.5)
    return False


def click_template(name, step_name, threshold=0.7):
    score, x, y = match_template(name)
    if score >= threshold and x is not None:
        pyautogui.click(x, y)
        log(f"{step_name} 点击 ({x},{y}) 匹配度 {score:.3f}")
        return True
    log(f"{step_name} 匹配度 {score:.3f}，未点击。")
    return False


def is_exit_ui_visible(threshold=0.8) -> bool:
    """检测退图界面（exit_step1/exit_step2 任一）"""
    for nm in ("exit_step1.png", "exit_step2.png"):
        score, _, _ = match_template(nm)
        if score >= threshold:
            log(f"检测到退图界面：{nm} 匹配度 {score:.3f}")
            return True
    return False


# ---------- 模板匹配（任意路径：人物密函 / 掉落物） ----------
def load_template_from_path(path: str):
    if cv2 is None or np is None:
        log("缺少 opencv/numpy，无法图像识别。")
        return None
    if not os.path.exists(path):
        log(f"模板不存在：{path}")
        return None
    data = np.fromfile(path, dtype=np.uint8)
    img = cv2.imdecode(data, cv2.IMREAD_GRAYSCALE)
    if img is None:
        log(f"无法读取模板：{path}")
    return img


def match_template_from_path(path: str):
    tpl = load_template_from_path(path)
    if tpl is None:
        return 0.0, None, None
    img = screenshot_game()
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    res = cv2.matchTemplate(gray, tpl, cv2.TM_CCOEFF_NORMED)
    _, max_val, _, max_loc = cv2.minMaxLoc(res)
    th, tw = tpl.shape[:2]
    x = GAME_REGION[0] + max_loc[0] + tw // 2
    y = GAME_REGION[1] + max_loc[1] + th // 2
    return max_val, x, y


def wait_and_click_template_from_path(path: str, step_name: str,
                                      timeout: float = 15.0,
                                      threshold: float = 0.8) -> bool:
    start = time.time()
    while time.time() - start < timeout and not worker_stop.is_set():
        score, x, y = match_template_from_path(path)
        log(f"{step_name} 匹配度 {score:.3f}")
        if score >= threshold and x is not None:
            pyautogui.click(x, y)
            log(f"{step_name} 点击 ({x},{y})")
            return True
        time.sleep(0.5)
    return False


# ---------- 宏回放（EMT 风格高精度） ----------
def load_actions(path: str):
    if not path or not os.path.exists(path):
        log(f"宏文件不存在：{path}")
        return []
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        log(f"加载宏失败：{e}")
        return []
    acts = data.get("actions", [])
    if not isinstance(acts, list) or not acts:
        log(f"宏文件中没有有效动作：{path}")
        return []
    acts.sort(key=lambda a: a.get("time", 0.0))
    return acts


def play_macro(path: str, label: str,
               p1: float, p2: float,
               interrupt_on_exit: bool = False):
    """
    EMT 风格高精度回放：
    - 按 actions 里的 time 字段作为绝对时间轴
    - time.perf_counter + 自旋保证时间精度
    - interrupt_on_exit=True 时，会周期性检测退图界面，发现就提前结束宏
    """
    if keyboard is None:
        log("未安装 keyboard 模块，无法回放宏。")
        return

    actions = load_actions(path)
    if not actions:
        return

    if not label:
        label = "宏"

    total_time = float(actions[-1].get("time", 0.0))
    total_actions = len(actions)
    log(f"{label}：共 {total_actions} 个动作，时长约 {total_time:.2f} 秒。")

    start_time = time.perf_counter()
    executed_count = 0
    keyboard_count = 0
    last_progress_percent = 0

    try:
        for i, action in enumerate(actions):
            if worker_stop.is_set():
                log(f"{label}：检测到停止信号，中断宏回放。")
                break

            if interrupt_on_exit and i % 5 == 0 and is_exit_ui_visible():
                log(f"{label}：检测到退图界面，提前结束宏。")
                break

            target_time = float(action.get("time", 0.0))
            elapsed = time.perf_counter() - start_time
            sleep_time = target_time - elapsed
            if sleep_time > 0:
                if sleep_time > 0.001:
                    time.sleep(max(0, sleep_time - 0.0005))
                while time.perf_counter() - start_time < target_time:
                    pass

            try:
                ttype = action.get("type", "key_down")
                key = action.get("key")
                if ttype == "key_down" and key:
                    keyboard.press(key)
                    keyboard_count += 1
                    executed_count += 1
                elif ttype == "key_up" and key:
                    keyboard.release(key)
                    executed_count += 1
            except Exception as e:
                log(f"{label}：动作 {i} 发送失败：{e}")
                continue

            local_progress = (i + 1) / total_actions
            global_p = p1 + local_progress * (p2 - p1)
            report_progress(global_p)

            percent = int(local_progress * 100)
            if percent - last_progress_percent >= 10:
                log(f"{label} 回放进度：{percent}%（键盘:{keyboard_count}）")
                last_progress_percent = percent

        actual_elapsed = time.perf_counter() - start_time
        time_diff = actual_elapsed - total_time
        accuracy = (1 - abs(time_diff) / total_time) * 100 if total_time > 0 else 100
        log(f"{label} 执行完成：")
        log(f"  预期时长：{total_time:.3f} 秒")
        log(f"  实际耗时：{actual_elapsed:.3f} 秒")
        log(f"  时间偏差：{time_diff * 1000:.1f} 毫秒")
        log(f"  时间轴还原精度：{accuracy:.2f}%")
        log(f"  执行动作：{executed_count}/{total_actions}（键盘:{keyboard_count}）")

    finally:
        pressed = set()
        for act in actions:
            if act.get("type") == "key_down":
                pressed.add(act.get("key"))
            elif act.get("type") == "key_up":
                pressed.discard(act.get("key"))
        if pressed:
            log(f"{label}：释放未松开的按键：{', '.join(k for k in pressed if k)}")
            for k in pressed:
                try:
                    if k:
                        keyboard.release(k)
                except Exception:
                    pass


# ======================================================================
#  赛琪大烟花（老项目）
# ======================================================================
def do_enter_buttons_first_round() -> bool:
    """第一轮需要 enter_step1 / enter_step2"""
    if not wait_and_click_template("enter_step1.png", "进入 步骤1", 20.0, 0.85):
        log("进入 步骤1 失败，本轮放弃。")
        return False
    if not wait_and_click_template("enter_step2.png", "进入 步骤2", 15.0, 0.85):
        log("进入 步骤2 失败，本轮放弃。")
        return False
    return True


def check_map_by_map1() -> bool:
    """只看 map1，阈值沿用 0.5"""
    if not wait_for_template("map1.png", "地图确认（map1）", 30.0, 0.5):
        log("地图匹配失败（map1 匹配度始终低于 0.5），本轮放弃。")
        return False
    return True


def do_exit_dungeon():
    wait_and_click_template("exit_step1.png", "退图 步骤1", 20.0, 0.8)
    wait_and_click_template("exit_step2.png", "退图 步骤2", 15.0, 0.8)


def emergency_recover():
    log("执行防卡死退图：ESC → G → Q → 退图")
    try:
        if keyboard is not None:
            keyboard.press_and_release("esc")
        else:
            pyautogui.press("esc")
    except Exception as e:
        log(f"发送 ESC 失败：{e}")
    time.sleep(1.0)
    click_template("G.png", "点击 G.png", 0.6)
    time.sleep(1.0)
    click_template("Q.png", "点击 Q.png", 0.6)
    time.sleep(1.0)
    do_exit_dungeon()


def run_one_round(wait_interval: float,
                  macro_a: str,
                  macro_b: str,
                  skip_enter_buttons: bool):
    log("===== 赛琪大烟花：新一轮开始 =====")
    report_progress(0.0)

    if not init_game_region():
        log("初始化游戏区域失败，本轮结束。")
        return

    if not skip_enter_buttons:
        if not do_enter_buttons_first_round():
            return

    if not check_map_by_map1():
        return

    log("地图确认成功，等待 2 秒让画面稳定…")
    t0 = time.time()
    while time.time() - t0 < 2.0 and not worker_stop.is_set():
        time.sleep(0.1)
    report_progress(0.3)

    play_macro(macro_a, "A 阶段（靠近大烟花）", 0.3, 0.6, interrupt_on_exit=True)
    if worker_stop.is_set():
        return

    if wait_interval > 0:
        log(f"等待大烟花爆炸 {wait_interval:.1f} 秒…")
        t0 = time.time()
        while time.time() - t0 < wait_interval and not worker_stop.is_set():
            time.sleep(0.1)

    play_macro(macro_b, "B 阶段（撤退）", 0.7, 0.95, interrupt_on_exit=True)
    if worker_stop.is_set():
        return

    if is_exit_ui_visible():
        log("检测到退图按钮，执行正常退图。")
        do_exit_dungeon()
    else:
        emergency_recover()

    report_progress(1.0)
    log("赛琪大烟花：本轮完成。")


def worker_loop(wait_interval: float,
                macro_a: str,
                macro_b: str,
                auto_loop: bool):
    try:
        first_round = True
        while not worker_stop.is_set():
            skip_enter = (auto_loop and not first_round)
            if skip_enter:
                log("自动循环：本轮跳过 enter_step1/2，只从地图确认(map1)开始。")
            run_one_round(wait_interval, macro_a, macro_b, skip_enter)
            first_round = False
            if worker_stop.is_set() or not auto_loop:
                break
            log("本轮结束，3 秒后继续下一轮…")
            time.sleep(3.0)
    except Exception as e:
        log(f"后台线程异常：{e}")
        traceback.print_exc()
    finally:
        report_progress(0.0)
        log("后台线程结束。")


# ---------- GUI：赛琪大烟花 ----------
class MainGUI:
    def __init__(self, root, cfg):
        self.root = root

        self.hotkey_var = tk.StringVar(value=cfg.get("hotkey", "1"))
        self.wait_var = tk.StringVar(value=str(cfg.get("wait_seconds", 8.0)))
        self.macro_a_var = tk.StringVar(value=cfg.get("macro_a_path", ""))
        self.macro_b_var = tk.StringVar(value=cfg.get("macro_b_path", ""))
        self.auto_loop_var = tk.BooleanVar(value=cfg.get("auto_loop", False))
        self.progress_var = tk.DoubleVar(value=0.0)

        self._build_ui()

    def _build_ui(self):
        top = tk.Frame(self.root)
        top.pack(fill="x", padx=10, pady=5)

        tk.Label(top, text="热键:").grid(row=0, column=0, sticky="e")
        tk.Entry(top, textvariable=self.hotkey_var, width=15).grid(row=0, column=1, sticky="w")
        ttk.Button(top, text="录制热键", command=self.capture_hotkey).grid(row=0, column=2, padx=3)
        ttk.Button(top, text="保存配置", command=self.save_cfg).grid(row=0, column=3, padx=3)

        tk.Label(top, text="烟花等待(秒):").grid(row=1, column=0, sticky="e")
        tk.Entry(top, textvariable=self.wait_var, width=8).grid(row=1, column=1, sticky="w")
        tk.Checkbutton(top, text="自动循环", variable=self.auto_loop_var).grid(row=1, column=2, sticky="w")

        frm2 = tk.LabelFrame(self.root, text="宏设置")
        frm2.pack(fill="x", padx=10, pady=5)

        tk.Label(frm2, text="A 宏（靠近大烟花）:").grid(row=0, column=0, sticky="e")
        tk.Entry(frm2, textvariable=self.macro_a_var, width=60).grid(row=0, column=1, sticky="w")
        ttk.Button(frm2, text="浏览…", command=self.choose_a).grid(row=0, column=2, padx=3)

        tk.Label(frm2, text="B 宏（撤退 / 退图前）:").grid(row=1, column=0, sticky="e")
        tk.Entry(frm2, textvariable=self.macro_b_var, width=60).grid(row=1, column=1, sticky="w")
        ttk.Button(frm2, text="浏览…", command=self.choose_b).grid(row=1, column=2, padx=3)

        frm3 = tk.Frame(self.root)
        frm3.pack(padx=10, pady=5)

        ttk.Button(frm3, text="开始监听热键", command=self.start_listen).grid(row=0, column=0, padx=3)
        ttk.Button(frm3, text="停止", command=self.stop_listen).grid(row=0, column=1, padx=3)
        ttk.Button(frm3, text="只执行一轮", command=self.run_once).grid(row=0, column=2, padx=3)

        frm4 = tk.LabelFrame(self.root, text="日志")
        frm4.pack(fill="both", expand=True, padx=10, pady=5)

        self.log_text = tk.Text(frm4, height=10)
        self.log_text.pack(side="left", fill="both", expand=True)
        sb = tk.Scrollbar(frm4, command=self.log_text.yview)
        sb.pack(side="right", fill="y")
        self.log_text.config(yscrollcommand=sb.set)

        self.progress = ttk.Progressbar(
            self.root,
            variable=self.progress_var,
            maximum=100.0,
            mode="determinate",
        )
        self.progress.pack(fill="x", padx=10, pady=5)

    def log(self, msg: str):
        ts = time.strftime("[%H:%M:%S] ")
        self.log_text.insert("end", ts + msg + "\n")
        self.log_text.see("end")

    def set_progress(self, p: float):
        self.progress_var.set(max(0.0, min(1.0, p)) * 100.0)

    # 事件
    def choose_a(self):
        p = filedialog.askopenfilename(
            title="选择 A 宏 JSON",
            initialdir=SCRIPTS_DIR,
            filetypes=[("JSON 文件", "*.json"), ("所有文件", "*.*")],
        )
        if p:
            self.macro_a_var.set(p)

    def choose_b(self):
        p = filedialog.askopenfilename(
            title="选择 B 宏 JSON",
            initialdir=SCRIPTS_DIR,
            filetypes=[("JSON 文件", "*.json"), ("所有文件", "*.*")],
        )
        if p:
            self.macro_b_var.set(p)

    def capture_hotkey(self):
        if keyboard is None:
            messagebox.showerror("错误", "未安装 keyboard，无法录制热键。")
            return
        log("请按下你想要的热键组合…")

        def worker():
            try:
                hk = keyboard.read_hotkey(suppress=False)
                self.hotkey_var.set(hk)
                log(f"捕获热键：{hk}")
            except Exception as e:
                log(f"录制热键失败：{e}")
        threading.Thread(target=worker, daemon=True).start()

    def save_cfg(self):
        try:
            cfg = {
                "hotkey": self.hotkey_var.get().strip(),
                "wait_seconds": float(self.wait_var.get()),
                "macro_a_path": self.macro_a_var.get(),
                "macro_b_path": self.macro_b_var.get(),
                "auto_loop": self.auto_loop_var.get(),
            }
            save_config(cfg)
        except Exception as e:
            messagebox.showerror("错误", f"保存配置失败：{e}")

    def ensure_macros(self) -> bool:
        if not self.macro_a_var.get() or not self.macro_b_var.get():
            messagebox.showwarning("提示", "请同时设置 A 宏和 B 宏。")
            return False
        return True

    def start_listen(self):
        global hotkey_handle
        if keyboard is None:
            messagebox.showerror("错误", "未安装 keyboard，无法使用热键监听。")
            return
        if not self.ensure_macros():
            return
        hk = self.hotkey_var.get().strip()
        if not hk:
            messagebox.showwarning("提示", "请先设置一个热键。")
            return

        worker_stop.clear()
        if hotkey_handle is not None:
            try:
                keyboard.remove_hotkey(hotkey_handle)
            except Exception:
                pass

        def on_hotkey():
            log("检测到热键，开始执行一轮。")
            self.start_worker(self.auto_loop_var.get())

        try:
            hotkey_handle = keyboard.add_hotkey(hk, on_hotkey)
        except Exception as e:
            messagebox.showerror("错误", f"注册热键失败：{e}")
            return
        log(f"开始监听热键：{hk}")

    def stop_listen(self):
        global hotkey_handle
        worker_stop.set()
        if keyboard is not None and hotkey_handle is not None:
            try:
                keyboard.remove_hotkey(hotkey_handle)
            except Exception:
                pass
        hotkey_handle = None
        log("已停止监听，当前轮结束后退出。")

    def start_worker(self, auto_loop: bool):
        if not self.ensure_macros():
            return
        if not round_running_lock.acquire(blocking=False):
            log("已有一轮在运行，本次忽略。")
            return
        wait_sec = float(self.wait_var.get())
        macro_a = self.macro_a_var.get()
        macro_b = self.macro_b_var.get()

        def worker():
            try:
                worker_loop(wait_sec, macro_a, macro_b, auto_loop)
            finally:
                round_running_lock.release()
        threading.Thread(target=worker, daemon=True).start()

    def run_once(self):
        self.start_worker(auto_loop=False)


# ======================================================================
#  扼守无尽血清 - 人物碎片自动刷取
# ======================================================================
class FragmentFarmGUI:
    MAX_LETTERS = 20

    def __init__(self, parent):
        self.parent = parent

        self.wave_var = tk.StringVar(value="10")
        self.timeout_var = tk.StringVar(value="160")
        self.target_frag_var = tk.StringVar(value="0")
        self.auto_loop_var = tk.BooleanVar(value=True)

        self.selected_letter_path = None
        self.macro_a_var = tk.StringVar(value="")
        self.macro_b_var = tk.StringVar(value="")

        self.letter_images = []
        self.letter_buttons = []

        self.drop_priority = []
        self.drop_listbox = None

        self.fragment_count = 0
        self.fragment_count_var = tk.StringVar(value="0")
        self.stat_name_var = tk.StringVar(value="（未选择）")
        self.stat_image = None
        self.finished_waves = 0

        self.run_start_time = None
        self.is_farming = False
        self.time_str_var = tk.StringVar(value="00:00:00")
        self.rate_str_var = tk.StringVar(value="0.00 碎片/波")
        self.eff_str_var = tk.StringVar(value="0.00 碎片/小时")
        self.target_fragments = 0

        self._build_ui()
        self._load_letters()
        self._load_drop_priority()

    # ---- UI ----
    def _build_ui(self):
        tip_top = tk.Label(
            self.parent,
            text="只能刷『无尽扼守』的血清，请使用高练度的大范围水母角色！",
            fg="red",
            font=("Microsoft YaHei", 10, "bold"),
        )
        tip_top.pack(fill="x", padx=10, pady=3)

        top = tk.Frame(self.parent)
        top.pack(fill="x", padx=10, pady=5)

        tk.Label(top, text="总波数:").grid(row=0, column=0, sticky="e")
        tk.Entry(top, textvariable=self.wave_var, width=6).grid(row=0, column=1, sticky="w", padx=3)
        tk.Label(top, text="（默认 10 波）").grid(row=0, column=2, sticky="w")

        tk.Label(top, text="局内超时(秒):").grid(row=0, column=3, sticky="e")
        tk.Entry(top, textvariable=self.timeout_var, width=6).grid(row=0, column=4, sticky="w", padx=3)
        tk.Label(top, text="（防卡死判定）").grid(row=0, column=5, sticky="w")

        tk.Label(top, text="目标碎片数:").grid(row=1, column=0, sticky="e")
        tk.Entry(top, textvariable=self.target_frag_var, width=6).grid(row=1, column=1, sticky="w", padx=3)
        tk.Label(top, text="（>=2 的偶数；0 或空=不限制）").grid(row=1, column=2, columnspan=4, sticky="w")

        ttk.Button(top, text="刷新人物密函列表", command=self._load_letters).grid(row=0, column=6, rowspan=2, padx=10)
        tk.Checkbutton(top, text="未达目标自动循环重开", variable=self.auto_loop_var).grid(row=1, column=6, sticky="w")

        frame_letters = tk.LabelFrame(self.parent, text="人物密函选择（来自 templates_letters/）")
        frame_letters.pack(fill="both", expand=True, padx=10, pady=5)

        self.letters_grid = tk.Frame(frame_letters)
        self.letters_grid.pack(fill="both", expand=True, padx=5, pady=5)

        self.selected_label_var = tk.StringVar(value="当前未选择人物密函")
        tk.Label(frame_letters, textvariable=self.selected_label_var, fg="#0080ff").pack(anchor="w", padx=5, pady=3)

        frame_macros = tk.LabelFrame(self.parent, text="地图宏脚本（mapA / mapB）")
        frame_macros.pack(fill="x", padx=10, pady=5)

        tk.Label(frame_macros, text="mapA 宏:").grid(row=0, column=0, sticky="e")
        tk.Entry(frame_macros, textvariable=self.macro_a_var, width=50).grid(row=0, column=1, sticky="w", padx=3)
        ttk.Button(frame_macros, text="浏览…", command=self._choose_macro_a).grid(row=0, column=2, padx=3)

        tk.Label(frame_macros, text="mapB 宏:").grid(row=1, column=0, sticky="e")
        tk.Entry(frame_macros, textvariable=self.macro_b_var, width=50).grid(row=1, column=1, sticky="w", padx=3)
        ttk.Button(frame_macros, text="浏览…", command=self._choose_macro_b).grid(row=1, column=2, padx=3)

        frame_drops = tk.LabelFrame(self.parent, text="掉落物优先级（从上到下）")
        frame_drops.pack(fill="x", padx=10, pady=5)

        self.drop_listbox = tk.Listbox(frame_drops, height=6)
        self.drop_listbox.grid(row=0, column=0, rowspan=3, padx=5, pady=5, sticky="nsew")

        tk.Button(frame_drops, text="上移", command=self._move_drop_up).grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        tk.Button(frame_drops, text="下移", command=self._move_drop_down).grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        tk.Button(frame_drops, text="刷新列表", command=self._load_drop_priority).grid(row=2, column=1, padx=5, pady=2, sticky="ew")

        frame_drops.columnconfigure(0, weight=1)

        stats = tk.LabelFrame(self.parent, text="人物碎片统计（实时）")
        stats.pack(fill="x", padx=10, pady=5)

        self.stat_image_label = tk.Label(stats, width=64, height=64, relief="sunken")
        self.stat_image_label.grid(row=0, column=0, rowspan=3, padx=5, pady=5)

        tk.Label(stats, text="当前人物：").grid(row=0, column=1, sticky="e")
        tk.Label(stats, textvariable=self.stat_name_var).grid(row=0, column=2, sticky="w")

        tk.Label(stats, text="累计碎片：").grid(row=1, column=1, sticky="e")
        tk.Label(stats, textvariable=self.fragment_count_var,
                 font=("Microsoft YaHei", 12, "bold"), fg="#ff6600").grid(row=1, column=2, sticky="w")

        tk.Label(stats, text="运行时间：").grid(row=0, column=3, sticky="e")
        tk.Label(stats, textvariable=self.time_str_var).grid(row=0, column=4, sticky="w")

        tk.Label(stats, text="平均掉落：").grid(row=1, column=3, sticky="e")
        tk.Label(stats, textvariable=self.rate_str_var).grid(row=1, column=4, sticky="w")

        tk.Label(stats, text="效率：").grid(row=2, column=3, sticky="e")
        tk.Label(stats, textvariable=self.eff_str_var).grid(row=2, column=4, sticky="w")

        ctrl = tk.Frame(self.parent)
        ctrl.pack(fill="x", padx=10, pady=5)
        self.start_btn = ttk.Button(ctrl, text="开始刷碎片", command=self.start_farming)
        self.start_btn.pack(side="left", padx=3)
        self.stop_btn = ttk.Button(ctrl, text="停止", command=self.stop_farming)
        self.stop_btn.pack(side="left", padx=3)

        log_frame = tk.LabelFrame(self.parent, text="人物碎片日志")
        log_frame.pack(fill="both", expand=True, padx=10, pady=5)
        self.log_text = tk.Text(log_frame, height=10)
        self.log_text.pack(side="left", fill="both", expand=True)
        sb = tk.Scrollbar(log_frame, command=self.log_text.yview)
        sb.pack(side="right", fill="y")
        self.log_text.config(yscrollcommand=sb.set)

        tip = tk.Label(
            self.parent,
            text=(
                "提示：\n"
                "1. 人物密函图片放入 templates_letters/ 目录，数量不限，本界面最多显示前 20 张。\n"
                "2. 掉落物图片放入 templates_drops/ 目录，文件名 1.png / 2.png / ...，数字越小默认优先级越高，可在上方调整顺序。\n"
                "3. 按钮图（选择密函/再次挑战/确认选择/撤退/mapa/mapb/G/Q/exit_step1）放在 templates/ 目录。\n"
            ),
            fg="#666666",
            anchor="w",
            justify="left",
        )
        tip.pack(fill="x", padx=10, pady=(0, 8))

    # ---- 日志 ----
    def log(self, msg: str):
        ts = time.strftime("[%H:%M:%S] ")
        self.log_text.insert("end", ts + msg + "\n")
        self.log_text.see("end")

    # ---- 人物密函 ----
    def _load_letters(self):
        for b in self.letter_buttons:
            b.destroy()
        self.letter_buttons.clear()
        self.letter_images.clear()

        files = []
        for name in os.listdir(TEMPLATE_LETTERS_DIR):
            low = name.lower()
            if low.endswith((".png", ".jpg", ".jpeg", ".gif", ".bmp")):
                files.append(name)
        files.sort()
        files = files[: self.MAX_LETTERS]

        if not files:
            self.selected_label_var.set("当前未选择人物密函（templates_letters/ 目录为空）")
            return

        max_per_row = 5
        for idx, name in enumerate(files):
            full_path = os.path.join(TEMPLATE_LETTERS_DIR, name)
            try:
                img = tk.PhotoImage(file=full_path)
                if img.width() > 128 or img.height() > 128:
                    sx = max(1, img.width() // 128)
                    sy = max(1, img.height() // 128)
                    img = img.subsample(sx, sy)
            except Exception:
                continue
            self.letter_images.append(img)
            r = idx // max_per_row
            c = idx % max_per_row
            btn = tk.Button(
                self.letters_grid,
                image=img,
                relief="raised",
                borderwidth=2,
                command=lambda p=full_path, b_idx=idx: self._on_letter_clicked(p, b_idx),
            )
            btn.grid(row=r, column=c, padx=4, pady=4)
            self.letter_buttons.append(btn)

        if self.selected_letter_path:
            try:
                base = os.path.basename(self.selected_letter_path)
                cur_idx = files.index(base)
                self._highlight_button(cur_idx)
            except ValueError:
                self.selected_letter_path = None
                self.selected_label_var.set("当前未选择人物密函")

    def _on_letter_clicked(self, path: str, idx: int):
        self.selected_letter_path = path
        base = os.path.basename(path)
        self.selected_label_var.set(f"当前选择人物密函：{base}")
        self._highlight_button(idx)
        self.stat_name_var.set(base)
        self.stat_image = self.letter_images[idx]
        self.stat_image_label.config(image=self.stat_image)

    def _highlight_button(self, idx: int):
        for i, btn in enumerate(self.letter_buttons):
            if i == idx:
                btn.config(relief="sunken", bg="#a0cfff")
            else:
                btn.config(relief="raised", bg="#f0f0f0")

    # ---- 掉落物优先级 ----
    def _load_drop_priority(self):
        files = []
        for name in os.listdir(TEMPLATE_DROPS_DIR):
            low = name.lower()
            if low.endswith((".png", ".jpg", ".jpeg", ".gif", ".bmp")):
                files.append(name)

        numeric = []
        others = []
        for name in files:
            base, _ = os.path.splitext(name)
            if base.isdigit():
                numeric.append((int(base), name))
            else:
                others.append(name)
        numeric.sort(key=lambda x: x[0])
        ordered = [n for _, n in numeric] + sorted(others)

        self.drop_priority = ordered
        self.drop_listbox.delete(0, "end")
        for n in self.drop_priority:
            self.drop_listbox.insert("end", n)

    def _move_drop_up(self):
        sel = self.drop_listbox.curselection()
        if not sel:
            return
        idx = sel[0]
        if idx <= 0:
            return
        self.drop_priority[idx - 1], self.drop_priority[idx] = (
            self.drop_priority[idx],
            self.drop_priority[idx - 1],
        )
        self._refresh_drop_listbox(idx - 1)

    def _move_drop_down(self):
        sel = self.drop_listbox.curselection()
        if not sel:
            return
        idx = sel[0]
        if idx >= len(self.drop_priority) - 1:
            return
        self.drop_priority[idx + 1], self.drop_priority[idx] = (
            self.drop_priority[idx],
            self.drop_priority[idx + 1],
        )
        self._refresh_drop_listbox(idx + 1)

    def _refresh_drop_listbox(self, sel_idx: int):
        self.drop_listbox.delete(0, "end")
        for n in self.drop_priority:
            self.drop_listbox.insert("end", n)
        if 0 <= sel_idx < len(self.drop_priority):
            self.drop_listbox.selection_set(sel_idx)
            self.drop_listbox.see(sel_idx)

    def _get_drop_templates_in_priority(self):
        if not self.drop_priority:
            self._load_drop_priority()
        return [os.path.join(TEMPLATE_DROPS_DIR, n) for n in self.drop_priority]

    # ---- 宏选择 ----
    def _choose_macro_a(self):
        p = filedialog.askopenfilename(
            title="选择 mapA 宏 JSON",
            initialdir=SCRIPTS_DIR,
            filetypes=[("JSON 文件", "*.json"), ("所有文件", "*.*")],
        )
        if p:
            self.macro_a_var.set(p)

    def _choose_macro_b(self):
        p = filedialog.askopenfilename(
            title="选择 mapB 宏 JSON",
            initialdir=SCRIPTS_DIR,
            filetypes=[("JSON 文件", "*.json"), ("所有文件", "*.*")],
        )
        if p:
            self.macro_b_var.set(p)

    # ---- 控制 ----
    def start_farming(self):
        if not self.selected_letter_path:
            messagebox.showwarning("提示", "请先选择一个人物密函。")
            return

        try:
            total_waves = int(self.wave_var.get().strip())
            if total_waves <= 0:
                raise ValueError
        except ValueError:
            messagebox.showwarning("提示", "总波数请输入大于 0 的整数。")
            return

        try:
            self.timeout_seconds = float(self.timeout_var.get().strip())
            if self.timeout_seconds <= 0:
                raise ValueError
        except ValueError:
            messagebox.showwarning("提示", "局内超时请输入大于 0 的数字秒数。")
            return

        target_text = self.target_frag_var.get().strip()
        if not target_text or target_text == "0":
            self.target_fragments = 0
        else:
            try:
                t = int(target_text)
                if t < 2 or t % 2 != 0:
                    raise ValueError
                self.target_fragments = t
            except ValueError:
                messagebox.showwarning("提示", "目标碎片数必须为 >=2 的偶数（或留空/0 表示不限制）。")
                return

        if not self.macro_a_var.get() or not self.macro_b_var.get():
            messagebox.showwarning("提示", "请设置 mapA 与 mapB 的宏 JSON。")
            return

        if pyautogui is None or cv2 is None or np is None:
            messagebox.showerror("错误", "缺少 pyautogui 或 opencv/numpy，无法刷碎片。")
            return
        if keyboard is None:
            messagebox.showerror("错误", "未安装 keyboard 模块，无法发送按键。")
            return

        if not round_running_lock.acquire(blocking=False):
            messagebox.showwarning("提示", "当前已有其它任务在运行，请先停止后再试。")
            return

        self.fragment_count = 0
        self.fragment_count_var.set("0")
        self.finished_waves = 0
        self.run_start_time = time.time()
        self.is_farming = True
        self._update_stats_ui()
        self.parent.after(1000, self._stats_timer)

        worker_stop.clear()
        self.start_btn.config(state="disabled")

        t = threading.Thread(target=self._farm_worker, args=(total_waves,), daemon=True)
        t.start()

    def stop_farming(self):
        worker_stop.set()
        messagebox.showinfo("提示", "已请求停止刷碎片，本波结束后将自动退出。")

    # ---- 统计 ----
    def _add_fragments(self, delta: int):
        if delta <= 0:
            return
        self.fragment_count += delta
        val = self.fragment_count

        def _update():
            self.fragment_count_var.set(str(val))
        self.parent.after(0, _update)

    def _update_stats_ui(self):
        if self.run_start_time is None:
            elapsed = 0
        else:
            elapsed = time.time() - self.run_start_time
        self.time_str_var.set(format_hms(elapsed))
        if self.finished_waves > 0:
            rate = self.fragment_count / self.finished_waves
        else:
            rate = 0.0
        self.rate_str_var.set(f"{rate:.2f} 碎片/波")
        if elapsed > 0:
            eff = self.fragment_count / (elapsed / 3600.0)
        else:
            eff = 0.0
        self.eff_str_var.set(f"{eff:.2f} 碎片/小时")

    def _stats_timer(self):
        if not self.is_farming:
            return
        self._update_stats_ui()
        self.parent.after(1000, self._stats_timer)

    # ---- 核心刷本流程 ----
    def _farm_worker(self, total_waves: int):
        try:
            log("===== 人物碎片刷取 开始 =====")
            if not init_game_region():
                messagebox.showerror("错误", "未找到『二重螺旋』窗口，无法开始刷碎片。")
                return

            auto_loop = self.auto_loop_var.get()
            first_session = True
            session_index = 0

            while not worker_stop.is_set():
                session_index += 1
                log(f"[碎片] === 开始第 {session_index} 趟无尽 ===")

                if first_session:
                    if not self._enter_first_wave_and_setup():
                        return
                    first_session = False
                else:
                    if not self._restart_from_lobby_after_retreat():
                        log("[碎片] 循环重开失败，结束刷取。")
                        break

                current_wave = 1
                need_next_session = False

                while current_wave <= total_waves and not worker_stop.is_set():
                    log(f"[碎片] 开始第 {current_wave} 波战斗挂机…")
                    result = self._battle_and_loot(max_wait=self.timeout_seconds)
                    if worker_stop.is_set():
                        break

                    if result == "timeout":
                        log(f"[碎片] 第 {current_wave} 波判定卡死，执行防卡死逻辑…")
                        if not self._anti_stuck_and_reset():
                            log("[碎片] 防卡死失败，结束刷取。")
                            need_next_session = False
                            break
                        # 防卡死后会重新地图识别+宏，继续当前波
                        continue

                    elif result == "ok":
                        self.finished_waves += 1
                        log(f"[碎片] 第 {current_wave} 波战斗完成。")

                        if self.target_fragments > 0 and self.fragment_count >= self.target_fragments:
                            log("[碎片] 已达到目标碎片数量，执行撤退并结束。")
                            self._retreat_only()
                            need_next_session = False
                            worker_stop.set()
                            break

                        if current_wave == total_waves:
                            if self.target_fragments == 0 or self.fragment_count >= self.target_fragments or not auto_loop:
                                log("[碎片] 到达设定波数（或未启用自动循环），撤退并结束。")
                                self._retreat_only()
                                need_next_session = False
                                worker_stop.set()
                                break
                            else:
                                log("[碎片] 波数已满但未达目标碎片，撤退并准备下一趟循环。")
                                self._retreat_only()
                                need_next_session = True
                                break
                        else:
                            if not self._enter_next_wave_without_map():
                                log("[碎片] 进入下一波失败，结束刷取。")
                                need_next_session = False
                                worker_stop.set()
                                break
                            current_wave += 1
                            continue

                    else:
                        need_next_session = False
                        break

                if worker_stop.is_set():
                    break
                if not auto_loop or self.target_fragments == 0 or not need_next_session:
                    break

            log("===== 人物碎片刷取 结束 =====")

        except Exception as e:
            log(f"[碎片] 后台线程异常：{e}")
            traceback.print_exc()
        finally:
            worker_stop.clear()
            round_running_lock.release()
            self.is_farming = False
            self._update_stats_ui()

            def restore():
                try:
                    self.start_btn.config(state="normal")
                except Exception:
                    pass
            self.parent.after(0, restore)

            if self.run_start_time is not None:
                elapsed = time.time() - self.run_start_time
                time_str = format_hms(elapsed)
                if self.finished_waves > 0:
                    rate = self.fragment_count / self.finished_waves
                else:
                    rate = 0.0
                if elapsed > 0:
                    eff = self.fragment_count / (elapsed / 3600.0)
                else:
                    eff = 0.0
                msg = (
                    f"人物碎片刷取已结束。\n\n"
                    f"总运行时间：{time_str}\n"
                    f"完成波数：{self.finished_waves}\n"
                    f"累计碎片：{self.fragment_count}\n"
                    f"平均掉落：{rate:.2f} 碎片/波\n"
                    f"效率：{eff:.2f} 碎片/小时\n"
                )
                self.parent.after(0, lambda: messagebox.showinfo("刷碎片完成", msg))

    # ---- 首次进图 / 循环重开 ----
    def _enter_first_wave_and_setup(self) -> bool:
        log("[碎片] 首次进图：选择密函按钮 → 用户密函 → 确认选择 → 地图AB识别 + 宏")
        if not wait_and_click_template(BTN_OPEN_LETTER, "[碎片] 首次：选择密函按钮", 25.0, 0.8):
            log("[碎片] 首次：未能点击 选择密函.png。")
            return False
        if not wait_and_click_template_from_path(
            self.selected_letter_path,
            "[碎片] 首次：点击人物密函",
            20.0,
            0.8,
        ):
            log("[碎片] 首次：未能点击人物密函。")
            return False
        if not wait_and_click_template(BTN_CONFIRM_LETTER, "[碎片] 首次：确认选择", 20.0, 0.8):
            log("[碎片] 首次：未能点击 确认选择.png。")
            return False
        return self._map_detect_and_run_macros()

    def _restart_from_lobby_after_retreat(self) -> bool:
        log("[碎片] 循环重开：exit_step1 → 选择密函 → 人物密函 → 确认选择 → 地图AB + 宏")
        if not wait_and_click_template("exit_step1.png", "[碎片] 循环重开：再次进入按钮", 25.0, 0.8):
            log("[碎片] 循环重开：未能点击 exit_step1.png。")
            return False
        if not wait_and_click_template(BTN_OPEN_LETTER, "[碎片] 循环重开：选择密函按钮", 20.0, 0.8):
            log("[碎片] 循环重开：未能点击 选择密函.png。")
            return False
        if not wait_and_click_template_from_path(
            self.selected_letter_path,
            "[碎片] 循环重开：点击人物密函",
            20.0,
            0.8,
        ):
            log("[碎片] 循环重开：未能点击人物密函。")
            return False
        if not wait_and_click_template(BTN_CONFIRM_LETTER, "[碎片] 循环重开：确认选择", 20.0, 0.8):
            log("[碎片] 循环重开：未能点击 确认选择.png。")
            return False
        return self._map_detect_and_run_macros()

    def _map_detect_and_run_macros(self) -> bool:
        """
        确认密函后，持续匹配 mapa / mapb：
        - 最多 12 秒
        - 任意一张匹配度 >= 0.7 就认定地图
        - 然后再等待 2 秒，最后执行对应宏
        """
        log("[碎片] 开始持续识别地图 A/B（最长 12 秒）…")

        deadline = time.time() + 12.0
        chosen = None
        score_a = 0.0
        score_b = 0.0

        while time.time() < deadline and not worker_stop.is_set():
            score_a, _, _ = match_template("mapa.png")
            score_b, _, _ = match_template("mapb.png")
            log(f"[碎片] mapa 匹配度 {score_a:.3f}，mapb 匹配度 {score_b:.3f}")

            best = max(score_a, score_b)
            if best >= 0.7:
                chosen = "A" if score_a >= score_b else "B"
                break

            time.sleep(0.4)

        if chosen is None:
            log("[碎片] 12 秒内地图匹配度始终低于 0.7，本趟放弃。")
            return False

        if chosen == "A":
            macro_path = self.macro_a_var.get()
            label = "mapA 宏"
        else:
            macro_path = self.macro_b_var.get()
            label = "mapB 宏"

        if not macro_path or not os.path.exists(macro_path):
            log(f"[碎片] {label} 文件不存在：{macro_path}")
            return False

        log(
            f"[碎片] 识别为 {label}（mapa={score_a:.3f}, mapb={score_b:.3f}），"
            "再等待 2 秒后执行宏…"
        )

        t0 = time.time()
        while time.time() - t0 < 2.0 and not worker_stop.is_set():
            time.sleep(0.1)

        play_macro(macro_path, f"[碎片] {label}", 0.0, 0.3, interrupt_on_exit=False)
        return True

    # ---- 掉落界面检测 & 掉落识别 ----
    def _is_drop_ui_visible(self, log_detail: bool = False, threshold: float = 0.7) -> bool:
        """
        判断当前是否已经进入『物品掉落选择界面』：
        用确认按钮『确认选择.png』做判定，匹配度 >= threshold 才算界面出现。
        """
        score, _, _ = match_template(BTN_CONFIRM_LETTER)
        if log_detail:
            log(f"[碎片] 掉落界面检查：确认选择 匹配度 {score:.3f}")
        return score >= threshold

    def _detect_and_pick_drop(self, threshold=0.6) -> bool:
        """
        已经确认『物品掉落界面』出现之后调用：

        1. 按当前优先级遍历 templates_drops/ 中的图片：
           - 默认顺序是 1.png → 2.png → 3.png → ...
           - 找到第一个匹配度 >= threshold 的，就作为本次选择的掉落物
        2. 点击该掉落物
        3. 如果是 1.png → 人物碎片 +10；2.png → +2；其它不计入碎片
        4. 然后再点击一次通用的『确认选择.png』
        """
        paths = self._get_drop_templates_in_priority()
        if not paths:
            return False

        for path in paths:
            score, x, y = match_template_from_path(path)
            name = os.path.basename(path)
            base, _ = os.path.splitext(name)

            if score >= threshold and x is not None:
                pyautogui.click(x, y)
                log(f"[碎片] 选择掉落物 {name}，匹配度 {score:.3f}")

                if base == "1":
                    self._add_fragments(10)
                elif base == "2":
                    self._add_fragments(2)

                click_template(
                    BTN_CONFIRM_LETTER,
                    "[碎片] 掉落确认：确认选择",
                    threshold=0.7,
                )

                return True

        return False

    def _battle_and_loot(self, max_wait: float = 160.0) -> str:
        """
        战斗挂机 + 掉落判断，严格遵守 max_wait（例如 160 秒）：

        - 宏执行完之后调用本函数
        - 每 5 秒按一次 E
        - 在 [0, max_wait] 内循环：
            1) 先判断『物品掉落界面』是否出现（确认选择.png 匹配度 >= 0.7）
            2) 只有界面出现以后，才去识别掉落物并选择
        - 如果在 max_wait 秒内成功选到了掉落物 → 返回 'ok'
        - 如果超过 max_wait 仍然没检测到掉落界面/没选到 → 返回 'timeout'
        """
        if keyboard is None and pyautogui is None:
            log("[碎片] 无法发送按键。")
            return "stopped"

        log(f"[碎片] 开始战斗挂机（每 5 秒按一次 E，超时 {max_wait:.1f} 秒）。")
        start = time.time()
        last_e = 0.0

        min_drop_check_time = 10.0
        drop_ui_visible = False
        last_ui_log = 0.0

        while not worker_stop.is_set():
            now = time.time()

            if now - last_e >= 5.0:
                try:
                    if keyboard is not None:
                        keyboard.press_and_release("e")
                    else:
                        pyautogui.press("e")
                except Exception as e:
                    log(f"[碎片] 发送 E 失败：{e}")
                last_e = now

            if now - start >= min_drop_check_time:
                if not drop_ui_visible:
                    if self._is_drop_ui_visible():
                        drop_ui_visible = True
                        log("[碎片] 检测到物品掉落界面，开始识别掉落物。")
                    else:
                        if now - last_ui_log > 3.0:
                            self._is_drop_ui_visible(log_detail=True)
                            last_ui_log = now
                else:
                    if self._detect_and_pick_drop():
                        log("[碎片] 本波掉落已选择。")
                        return "ok"

            if now - start > max_wait:
                log(f"[碎片] 超过 {max_wait:.1f} 秒未检测到掉落，判定卡死。")
                return "timeout"

            time.sleep(0.5)

        return "stopped"

    # ---- 正常进入下一波（不做地图识别） ----
    def _enter_next_wave_without_map(self) -> bool:
        log("[碎片] 进入下一波：再次挑战 → 选择密函 → 人物密函 → 确认选择")
        if not wait_and_click_template(BTN_NEXT_WAVE, "[碎片] 下一波：再次挑战按钮", 25.0, 0.8):
            log("[碎片] 下一波：未能点击 再次挑战.png。")
            return False
        if not wait_and_click_template(BTN_OPEN_LETTER, "[碎片] 下一波：选择密函按钮", 20.0, 0.8):
            log("[碎片] 下一波：未能点击 选择密函.png。")
            return False
        if not wait_and_click_template_from_path(
            self.selected_letter_path,
            "[碎片] 下一波：点击人物密函",
            20.0,
            0.8,
        ):
            log("[碎片] 下一波：未能点击人物密函。")
            return False
        if not wait_and_click_template(BTN_CONFIRM_LETTER, "[碎片] 下一波：确认选择", 20.0, 0.8):
            log("[碎片] 下一波：未能点击 确认选择.png。")
            return False
        time.sleep(2.0)
        return True

    # ---- 防卡死 ----
    def _anti_stuck_and_reset(self) -> bool:
        """
        防卡死：Esc → G → Q → exit_step1 → 选择密函 → 人物密函 → 确认 → 地图识别
        """
        try:
            if keyboard is not None:
                keyboard.press_and_release("esc")
            else:
                pyautogui.press("esc")
        except Exception as e:
            log(f"[碎片] 发送 ESC 失败：{e}")
        time.sleep(1.0)
        click_template("G.png", "[碎片] 防卡死：点击 G.png", 0.6)
        time.sleep(1.0)
        click_template("Q.png", "[碎片] 防卡死：点击 Q.png", 0.6)
        time.sleep(1.0)

        if not wait_and_click_template("exit_step1.png", "[碎片] 防卡死：再次进入按钮", 25.0, 0.8):
            log("[碎片] 防卡死：未能点击 exit_step1.png。")
            return False
        if not wait_and_click_template(BTN_OPEN_LETTER, "[碎片] 防卡死：选择密函按钮", 20.0, 0.8):
            log("[碎片] 防卡死：未能点击 选择密函.png。")
            return False
        if not wait_and_click_template_from_path(
            self.selected_letter_path,
            "[碎片] 防卡死：点击人物密函",
            20.0,
            0.8,
        ):
            log("[碎片] 防卡死：未能点击人物密函。")
            return False
        if not wait_and_click_template(BTN_CONFIRM_LETTER, "[碎片] 防卡死：确认选择", 20.0, 0.8):
            log("[碎片] 防卡死：未能点击 确认选择.png。")
            return False
        return self._map_detect_and_run_macros()

    # ---- 撤退 ----
    def _retreat_only(self):
        wait_and_click_template(BTN_RETREAT_START, "[碎片] 撤退按钮", 20.0, 0.8)


# ======================================================================
#  main
# ======================================================================
def main():
    global app, fragment_app
    cfg = load_config()

    root = tk.Tk()
    root.title("苏苏多功能自动化工具")

    # 简单自适应分辨率 + DPI 缩放
    sw = root.winfo_screenwidth()
    sh = root.winfo_screenheight()

    try:
        base_h = 1080
        scale = max(1.0, min(1.5, sh / base_h))
        root.tk.call("tk", "scaling", scale)
    except Exception:
        pass

    win_w = min(1350, int(sw * 0.95))
    win_h = min(900, int(sh * 0.95))
    pos_x = (sw - win_w) // 2
    pos_y = (sh - win_h) // 2
    root.geometry(f"{win_w}x{win_h}+{pos_x}+{pos_y}")
    root.minsize(1000, 650)

    try:
        root.state("zoomed")
    except Exception:
        pass

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True)

    frame_firework = ttk.Frame(notebook)
    notebook.add(frame_firework, text="赛琪大烟花")
    app = MainGUI(frame_firework, cfg)

    frame_fragment = ttk.Frame(notebook)
    notebook.add(frame_fragment, text="扼守无尽血清-人物碎片自动刷取")
    fragment_app = FragmentFarmGUI(frame_fragment)

    log("苏苏多功能自动化工具 已启动。")
    root.mainloop()


if __name__ == "__main__":
    main()
